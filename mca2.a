;ACME 0.96.2
; Name		mca2
; Purpose	multiple choice adventure 2
; Author	(c) Marco Baye, 2017
; Licence	Free software
; Changes:
;  3 Sep 2016	First try, posted to forum64
;  4 Sep 2016	added some comments and shaved off a byte
; 24 Jun 2017	started work to convert from original mca to mca2
; 26 Jun 2017	got it to work

	!src <cbm/c64/petscii.a>
	!src <cbm/c64/vic.a>
	!src <cbm/c64/kernal.a>
	!ct pet

	DEUTSCH	= 1;0	; set to nonzero to make engine use german texts

; helper values
	CR		= 13
	MODIFIED8	= $ff

; system memory
!addr	is_PAL		= $02a6	; zero for NTSC, nonzero for PAL

; basic header
	* = $0801
		!wo line2, 2017
		!by $9e, $20	; "sys "
		!by '0' + entry % 10000 / 1000
		!by '0' + entry %  1000 /  100
		!by '0' + entry %   100 /   10
		!by '0' + entry %    10
		!pet $3a, $8f, " saufbox!", $0	; ":rem "
line2		!wo 0


xor_border ; this is used by the example program
		lda addr($d020)
		eor #15
		sta addr($d020)
		rts

wait_A_tenths ; wait for the number of .1 seconds given in A
		; convert .1s unit to frames:
		;	for PAL (50Hz), multiply by 5 (4+1)
		;	for NTSC (60Hz), multiply by 6 (4+1+1)
		sta .tenths
		asl	; *2
		asl	; *4
		clc
		adc #MODIFIED8	: .tenths = * - 1	; *5
		; for NTSC, add another time
		ldx is_PAL
		bne +
			clc
			adc .tenths	; *6
+		;FALLTHROUGH
wait_A_frames ; wait for the number of frames given in A
		tax
---
-			lda vic_controlv
			bpl -
		txa	; check for early exit (if called with A zero)
		beq +	; early exit
-			lda vic_controlv
			bmi -
		dex
		bne ---
+		rts

; main program
entry ; entry point for SYS
		; init
		cld
		tsx
		stx sp_buffer
		lda #0
		sta vic_cborder
		sta vic_cbg
		jsr my_primm
		!tx petscii_LOCK, petscii_LOWERCASE, petscii_GREEN, petscii_CLEAR
!if DEUTSCH {
		!tx "Willkommen zu ", cr, '"', "Multiple Choice Adventure 2", '"', "!"
} else {
		!tx "Welcome to Multiple Choice Adventure 2!"
}
		!tx cr, 0
		jmp engine_new_sit

;internal_error	jsr my_primm
;		!tx "Internal error!", CR, 0
exit		ldx #MODIFIED8	: sp_buffer = * - 1
		txs
		rts

; print immediate
my_primm	pla	; get low byte of return address - 1
		tay	; into Y
		pla	; get high byte of return address - 1
		sta .primm_ptr + 1	; to ptr high
		jmp +
---			jsr k_chrout
+			iny
			bne +
				inc .primm_ptr + 1	; fix high byte
+			; high byte gets MODIFIED, but low byte stays zero!
			lda addr($ff00), y	: .primm_ptr = * - 2
			bne ---
		; push updated address onto stack
		lda .primm_ptr + 1
		pha
		tya
		pha
		rts	; return to caller (after zero-terminated text)


pre_sit ; called before a new situation (to clear screen?)
		; make some space
		jsr my_primm	: !tx petscii_CLEAR, 0	; was: CR, CR, 0
		rts

prompt_for_action ; ask user. returns chosen situation in YYAA
!if DEUTSCH {
		jsr my_primm	: !tx CR, "Zur Wahl stehen [", 0
} else {
		jsr my_primm	: !tx CR, "Please choose from [", 0
}
		ldy #0	; debug counter
		ldx #0
--			lda directions_hi, x
			beq +
				iny	; count
				lda direction_keys, x
				jsr k_chrout
+			inx
			cpx #6
			bne --
		; FIXME - add alternatives as well!
		tya
		beq no_choice
!if DEUTSCH {
		jsr my_primm	: !tx "]. Was darf es sein", 0
} else {
		jsr my_primm	: !tx "]. Your choice", 0
}
		; ask user for input
---			lda #'?'
			jsr k_chrout
			; wait for valid input
-				jsr k_getin
				beq -
			ldx #6
--				cmp direction_keys - 1, x
				beq .dir_x
				dex
				bne --
			beq ---
			;---
.dir_x			lda directions_hi - 1, x
			beq ---
		tay
		lda directions_lo - 1, x
		rts	; return YYAA as new sit
