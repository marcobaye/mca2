;ACME 0.96.2
; Name		mca2
; Purpose	multiple choice adventure 2
; Author	(c) Marco Baye, 2017
; Licence	Free software
; Changes:
;  3 Sep 2016	First try, posted to forum64
;  4 Sep 2016	added some comments and shaved off a byte
; 24 Jun 2017	started work to convert from original mca to mca2
; 26 Jun 2017	got it to work

	!src <6502/std.a>	; for +bit16
	!src <cbm/c64/petscii.a>
	!src <cbm/c64/vic.a>
	!src <cbm/c64/kernal.a>
	;!ct pet	; disabled, strings are now in UTF8

	DEUTSCH	= 1;0	; set to nonzero to make engine use german texts

; helper values
	CR		= 13
	MODIFIED8	= $ff

; system memory
!addr	currentcolor	= $0286
!addr	is_PAL		= $02a6	; zero for NTSC, nonzero for PAL

; basic header
	* = $0801
		!wo line2, 2017
		!by $9e, $20	; "sys "
		!by '0' + entry % 10000 / 1000
		!by '0' + entry %  1000 /  100
		!by '0' + entry %   100 /   10
		!by '0' + entry %    10
		!pet $3a, $8f, " saufbox!", $0	; ":rem "
line2		!wo 0


xor_border ; this is used by the example program
		lda addr($d020)
		eor #15
		sta addr($d020)
		rts

wait_A_tenths ; wait for the number of .1 seconds given in A
		; convert .1s unit to frames:
		;	for PAL (50Hz), multiply by 5 (4+1)
		;	for NTSC (60Hz), multiply by 6 (4+1+1)
		sta .tenths
		asl	; *2
		asl	; *4
		clc
		adc #MODIFIED8	: .tenths = * - 1	; *5
		; for NTSC, add another time
		ldx is_PAL
		bne +
			clc
			adc .tenths	; *6
+		;FALLTHROUGH
wait_A_frames ; wait for the number of frames given in A
		tax
---
-			lda vic_controlv
			bpl -
		txa	; check for early exit (if called with A zero)
		beq +	; early exit
-			lda vic_controlv
			bmi -
		dex
		bne ---
+		rts

; main program
entry ; entry point for SYS
		; init
		cld
		tsx
		stx sp_buffer
		lda #0
		sta vic_cborder
		sta vic_cbg
		jsr my_primm
		!tx petscii_LOCK, petscii_LOWERCASE, color_GREEN, petscii_CLEAR
!if DEUTSCH {
		!tx "Willkommen zu ", cr, '"', "Multiple Choice Adventure 2", '"', "!"
} else {
		!tx "Welcome to Multiple Choice Adventure 2!"
}
		!tx cr, 0
		jmp engine_new_location

;internal_error	jsr my_primm
;		!tx "Internal error!", CR, 0
exit		ldx #MODIFIED8	: sp_buffer = * - 1
		txs
		rts

; wrapper for CHROUT (to convert UTF8 to PetSCII)
my_chrout ; must keep X/Y!
		; check for A..Z
		cmp #'A'
		bcc +++	; $00..$40 are kept
		cmp #'Z' + 1
		bcs +
			; convert A..Z
			ora #$80
			jmp k_chrout
+		; check for a..z
		cmp #'a'
		bcc +++	; [\]^_` are kept
		cmp #'z' + 1
		bcs +
			; convert a..z
			and #$df
			jmp k_chrout
+		; check for (own) color codes ($fX)
		cmp #$f0
		bcc +
			; set color
			sta currentcolor
.rts			rts
+		; check for äöüßÄÖÜ and replace
;encoded as 0xc3 0x80 .. 0xc3 0x9f:
;	ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß	ÄÖÜß are $84, $96, $9c, $9f
;encoded as 0xc3 0xa0 .. 0xc3 0xbf:
;	àáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ	äöü are $a4, $b6, $bc
		; three of these clash with original petscii color codes, therefore this game now uses its own set of color codes (see above)
		cmp #$84	; petscii_HELP (so forget it)
		beq .Ä
		cmp #$96	; petscii_LRED
		beq .Ö
		cmp #$9c	; petscii_PURPLE
		beq .Ü
		cmp #$9f	; petscii_CYAN
		beq .ß
; äöü codes are kept, because they are mapped to graphics characters anyway (put glyphs at correct position in charset!)
		cmp #$c3	; prefix code? drop! (horizontal bar)
		bne +++
		rts
		; FIXME - replace ÄÖÜß with correct codes for chosen charset!
		; good candidates: ac, b5, bb, be
.Ä		lda #$ac
		+bit16
.Ö		lda #$b5
		+bit16
.Ü		lda #$bb
		+bit16
.ß		lda #$be
+++		jmp k_chrout

; print immediate
my_primm	pla	; get low byte of return address - 1
		tay	; into Y
		pla	; get high byte of return address - 1
		sta .primm_ptr + 1	; to ptr high
		jmp +
---			jsr my_chrout
+			iny
			bne +
				inc .primm_ptr + 1	; fix high byte
+			; high byte gets MODIFIED, but low byte stays zero!
			lda addr($ff00), y	: .primm_ptr = * - 2
			bne ---
		; push updated address onto stack
		lda .primm_ptr + 1
		pha
		tya
		pha
		rts	; return to caller (after zero-terminated text)


print_AAYY ; print zero-terminated string. keeps X.
		sta .print_ptr + 1
		; high byte gets MODIFIED, but low byte stays zero!
		jmp +
---			jsr my_chrout
			iny
			bne +
				inc .print_ptr + 1	; fix high byte
+			lda addr($ff00), y	: .print_ptr = * - 2
			bne ---
		rts

pre_situation ; called before a new situation (to clear screen?)
		; make some space
		jsr my_primm	: !tx petscii_CLEAR, 0	; was: CR, CR, 0
		rts

prompt_for_action ; ask user. returns chosen location in YYAA
		jsr my_primm	: !tx CR, ">", 0
		; ask user for input
---			lda #'?'
			jsr my_chrout
			; wait for valid input
-				jsr k_getin
				beq -
			ldx #6
--				cmp direction_keys - 1, x
				beq .dir_x
				dex
				bne --
			beq ---
			;---
.dir_x			lda directions_hi - 1, x
			beq ---
		tay
		lda directions_lo - 1, x
		rts	; return YYAA as new location

!if DEUTSCH {
direction_keys	!pet "nswohr"	; FIXME - still needed?
} else {
direction_keys	!pet "nsweud"	; FIXME - still needed?
}
