;ACME 0.96.2
; Name		mca2
; Purpose	multiple choice adventure 2
; Author	(c) Marco Baye, 2017
; Licence	Free software
; Changes:
;  3 Sep 2016	First try, posted to forum64
;  4 Sep 2016	added some comments and shaved off a byte
; 24 Jun 2017	started work to convert from original mca to mca2
; 26 Jun 2017	got it to work

	!src <6502/std.a>	; for +bit16
	;!ct pet	; disabled, strings are now in UTF8

	DEUTSCH	= 1;0	; set to nonzero to make engine use german texts

; helper values
	MODIFIED8	= $ff
	LIST_LEN_LIMIT	= 24	; with prompt underneath, screen shouldn't scroll

; zp variables
;!addr	fac1		= $61	; floating point registers could be used for temp storage
!addr	runptr		= $fb	; points to next bytecode instruction (also used for inline text output and scanning of usage list)
!addr	recursion_depth	= $fd	; counts recursion levels
;!addr	...		= $fe
!addr	tmp		= $ff	; currently only used by C128 font copier

; system memory
!if SYSTEM = 64 {
	KEYPAD		= 0
!addr	is_PAL		= $02a6	; zero for NTSC, nonzero for PAL
	load_addr	= $0801
}
!if SYSTEM = 128 {
	KEYPAD		= 1
!addr	z_keychk	= $033c	; fn ptr for f-key string expansion
!addr	is_PAL		= $0a03	; zero for NTSC, nonzero for PAL
	load_addr	= $1c01
	!src <cbm/c128/mmu.a>
}
; basic header
	* = load_addr
		!wo line2, 2017
!if SYSTEM = 128 {
		!by $fe, $25, $3a, $fe, $02, $20, $30, $3a	; "fast:bank 0:"
		!by $de, $20, $9c, $3a, $de, $20, $35, $3a	; "graphic clr:graphic 5:"
}
		!by $9e, $20	; "sys "
		!by '0' + entry % 10000 / 1000
		!by '0' + entry %  1000 /  100
		!by '0' + entry %   100 /   10
		!by '0' + entry %    10
		!by $3a, $8f, $20	; ":rem "
		!pet "saufbox!", 0
line2		!wo 0


xor_border ; this is used by the example program
		lda vic_cborder
		eor #15
		sta vic_cborder
		rts

wait_A_tenths ; wait for the number of .1 seconds given in A
		; convert .1s unit to frames:
		;	for PAL (50Hz), multiply by 5 (4+1)
		;	for NTSC (60Hz), multiply by 6 (4+1+1)
		sta .tenths
		asl	; *2
		asl	; *4
		clc
		adc #MODIFIED8	: .tenths = * - 1	; *5
		; for NTSC, add another time
		ldx is_PAL
		bne +
			clc
			adc .tenths	; *6
+		;FALLTHROUGH
wait_A_frames ; wait for the number of frames given in A
		tax
---
-				lda vic_controlv
				bpl -
			txa	; check for early exit (if called with A zero)
			beq +	; early exit
-				lda vic_controlv
				bmi -
			dex
			bne ---
+		rts

get_key ; wait for user to press key
		lda #0
		jsr my_chrout	; force flushing of word wrap buffer
---			jsr k_getin
			beq ---
		rts

; main program
entry ; entry point for SYS
		; init
		cld
		tsx
		stx sp_buffer
!if SYSTEM = 128 {
		lda #%....111.	; ram0, kernal, i/o
		sta mmu_cr
		lda #<$c6b7	; this will skip the first few bytes of the original routine
		sta z_keychk	; and therefore disable F key string expansion
}
		; FIXME - fadeout!
		lda #0
		sta vic_cborder
		sta vic_cbg
		jsr output_init
		; FIXME - fade in!
		jsr my_primm	: !tx color_std, petscii_CLEAR, 0
		jsr output_set_colors
; now enter actual main loop:
		jsr engine_check_restart	; reset vars to default?
		jsr indent1
		lda #<proc_intro
		ldy #>proc_intro
		jsr interpreter_run_YYAA
		jsr engine_new_location	; show start location
		jsr inventory	; show inventory once without being asked
; actual main loop:
		; wait for command
.get			jsr show_paths
			jsr get_key
			ldx #0
--				cmp keys_start, x
				bne +
					; found, so call action handler
					lda action_lo, x
					sta .call
					lda action_hi, x
					sta .call + 1
					jsr MODIFIED16	: .call = * - 2
					jmp .get
+				inx
				cpx #keys_end - keys_start
				bne --
			jsr my_primm
!if DEUTSCH {	!tx "(falsche Taste, dr", ü, "ck '?' f", ü, "r Hilfe)", cr, 0
} else {	!tx "(wrong key, press '?' for help)", cr, 0 }
			jmp .get

help ; "?" command
		jsr my_primm
!if DEUTSCH {	!tx cr, "M", ö, "gliche Befehle:", cr, color_emph
		!tx "  Nord S", ü, "d West Ost Hoch Runter", cr
		!tx "  Inventar(=F3) Grabsch Verliere", cr
		!tx "  Untersuche Benutze", cr, color_std
		!tx "Immer nur den ersten Buchstaben tippen!", cr
		!tx "CLR/HOME(=F1) baut den Bildschirm neu auf.", cr
		!tx "Zum Bewegen k", ö, "nnen auch die Cursortasten und +/- benutzt werden"
	!if KEYPAD {
		!tx ", au", ß, "erdem die Zehnertastatur."
	}
		!tx "."
} else {	!tx "Allowed commands:", cr
		!tx "  North South West East Up Down", cr
		!tx "Inventory(=F3) Take Lose", cr
		!tx "eXamine Combine", cr
		!tx "Type the first character only!", cr
		!tx "CLR/HOME(=F1) will redisplay the screen.", cr
		!tx "Moving around can also be done using the cursor and +/- keys"
	!if KEYPAD {
		!tx ", and the numerical keypad is also possible"
	}
		!tx "."
}
		!tx cr, 0
		rts

keys_start
		!pet petscii_UP, petscii_DOWN, petscii_LEFT, petscii_RIGHT, '+', '-'
!if KEYPAD {	!pet '8', '2', '4', '6', '5'	}
!if DEUTSCH {	!pet petscii_CLEAR, petscii_HOME, petscii_F1, petscii_F3, "?nswohrigvub"
} else {	!pet petscii_CLEAR, petscii_HOME, petscii_F1, petscii_F3, "?nsweuditlxc"	}
keys_end

action_lo	!by <go_n, <go_s, <go_w, <go_e, <go_u, <go_d
!if KEYPAD {	!by <go_n, <go_s, <go_w, <go_e, <redisp	}
		!by <redisp, <redisp, <redisp, <inventory, <help, <go_n, <go_s, <go_w, <go_e, <go_u, <go_d, <inventory, <take, <lose, <examine, <combine
action_hi	!by >go_n, >go_s, >go_w, >go_e, >go_u, >go_d
!if KEYPAD {	!by >go_n, >go_s, >go_w, >go_e, >redisp	}
		!by >redisp, >redisp, >redisp, >inventory, >help, >go_n, >go_s, >go_w, >go_e, >go_u, >go_d, >inventory, >take, >lose, >examine, >combine

	redisp = engine_new_location

; direction commands
go_n		ldx #offset_NORTH
		+bit16
go_s		ldx #offset_SOUTH
		+bit16
go_w		ldx #offset_WEST
		+bit16
go_e		ldx #offset_EAST
		+bit16
go_u		ldx #offset_UP
		+bit16
go_d		ldx #offset_DOWN
		lda directions_hi, x
		bne +
			; player chose an illegal direction
			jsr indent1
			jsr my_primm
!if DEUTSCH {		!tx "Richtung nicht m", ö, "glich, bitte eine andere w", ä, "hlen.", cr, 0
} else {		!tx "Illegal direction, please choose another.", cr, 0	}
			rts
+		tay
		lda directions_lo, x
		sty gamevars_hi + vo_PLAYER
		sta gamevars_lo + vo_PLAYER
		jmp engine_new_location

inventory ; "inventory" command
		jsr my_primm
!if DEUTSCH {	!tx "Dinge im Inventar:", 0
} else {	!tx "Things in inventory:", 0	}
		ldy #>location_INVENTORY
		lda #<location_INVENTORY
		jsr itemlist_at_YYAA_new
		jmp itemlist_list

take ; "take" command
		jsr my_primm
!if DEUTSCH {	!tx "Grabsch:", cr, 0
} else {	!tx "Take:", cr, 0	}
		ldy gamevars_hi + vo_PLAYER
		lda gamevars_lo + vo_PLAYER
		jsr itemlist_at_YYAA_new	; returns number in Y, A and Z ;)
		bne +
			jsr my_primm
!if DEUTSCH {		!tx " Nichts da zum Grabschen!", cr, 0
} else {		!tx " There is nothing to take!", cr, 0	}
			rts
+		ldx #1	; yes, do size checking
		jsr itemlist_menu_X_X	; returns first illegal index in X
		jsr select	; returns status in C and maybe index in X
		bcc +
			jsr my_primm
!if DEUTSCH {		!tx "- nichts gegrabscht!", cr, 0
} else {		!tx "- nothing taken!", cr, 0	}
			rts
+		jsr my_primm	: !tx ":", cr, 0
		; check size
		lda item_weight, x
		bpl +
			jsr my_primm
!if DEUTSCH {		!tx "Nein, das kann man nicht mitnehmen!", cr, 0
} else {		!tx "No, you cannot take that with you!", cr, 0	}
			rts
+		; take: set item's location to INVENTORY
		lda #>location_INVENTORY
		sta gamevars_hi, x
		lda #<location_INVENTORY
		sta gamevars_lo, x
		jsr my_primm
!if DEUTSCH {	!tx "Ok, gegrabscht!", cr, 0
} else {	!tx "Ok, took it!", cr, 0	}
		rts

lose ; "lose" command
		jsr my_primm
!if DEUTSCH {	!tx "Verliere:", cr, 0
} else {	!tx "Lose:", cr, 0	}
		ldy #>location_INVENTORY
		lda #<location_INVENTORY
		jsr itemlist_at_YYAA_new	; returns number in Y, A and Z ;)
		bne +
			jsr my_primm
!if DEUTSCH {		!tx " Nichts da zum Verlieren!", cr, 0
} else {		!tx " There is nothing to lose!", cr, 0	}
			rts
+		ldx #0	; no size check
		jsr itemlist_menu_X_X	; returns first illegal index in X
		jsr select	; returns status in C and maybe index in X
		bcc +
			jsr my_primm
!if DEUTSCH {		!tx "- nichts verloren!", cr, 0
} else {		!tx "- nothing lost!", cr, 0	}
			rts
+		jsr my_primm	: !tx ":", cr, 0
		; drop: copy player's location to item's location
		lda gamevars_hi + vo_PLAYER
		sta gamevars_hi, x
		lda gamevars_lo + vo_PLAYER
		sta gamevars_lo, x
		jsr my_primm
!if DEUTSCH {	!tx "Ok, verloren!", cr, 0
} else {	!tx "Ok, lost it!", cr, 0	}
		rts

examine ; "examine" command
		jsr my_primm
!if DEUTSCH {	!tx "Untersuche:", cr, 0
} else {	!tx "Examine:", cr, 0	}
		; get list of items at location
		ldy gamevars_hi + vo_PLAYER
		lda gamevars_lo + vo_PLAYER
		jsr itemlist_at_YYAA_new
		; extend list with items in inventory
		ldy #>location_INVENTORY
		lda #<location_INVENTORY
		jsr itemlist_at_YYAA_add	; returns number in Y, A and Z ;)
		bne +
			jsr my_primm
!if DEUTSCH {		!tx " Nichts da zum Untersuchen!", cr, 0
} else {		!tx " There is nothing to examine!", cr, 0	}
			rts
+		ldx #0	; no size check
		jsr itemlist_menu_X_X	; returns first illegal index in X
		jsr select	; returns status in C and maybe index in X
		bcc +
			jsr my_primm
!if DEUTSCH {		!tx "- nichts untersucht!", cr, 0
} else {		!tx "- nothing examined!", cr, 0	}
			rts
+		jsr my_primm	: !tx ":", cr, 0
		; examine: execute item's description code
		jsr indent1
		jsr engine_describe_X
		jsr my_primm	: !tx color_std, cr, 0
		rts

combine ; "combine" command
		jsr my_primm
!if DEUTSCH {	!tx "Benutze:", cr, 0
} else {	!tx "Combine:", cr, 0	}
		; get list of items in inventory
		ldy #>location_INVENTORY
		lda #<location_INVENTORY
		jsr itemlist_at_YYAA_new
		; extend list with items at location
		ldy gamevars_hi + vo_PLAYER
		lda gamevars_lo + vo_PLAYER
		jsr itemlist_at_YYAA_add	; returns number in Y, A and Z ;)
		bne +
			jsr my_primm
!if DEUTSCH {		!tx " Nichts da zum Benutzen!", cr, 0
} else {		!tx " There is nothing to combine!", cr, 0	}
			rts
+		; choose first item
		ldx #0	; no size check
		jsr itemlist_menu_X_X	; returns first illegal index in X
		jsr select	; returns status in C and maybe index in X
		bcc +
.no_combi		jsr my_primm
!if DEUTSCH {		!tx "- nichts benutzt!", cr, 0
} else {		!tx "- nothing combined!", cr, 0	}
			rts
+		stx .hinz
		; choose second item
		jsr my_primm
!if DEUTSCH {	!tx " mit:", cr, 0
} else {	!tx " with:", cr, 0	}
		ldx #0	; no size check
		jsr itemlist_menu_X_X	; returns first illegal index in X
		jsr select	; returns status in C and maybe index in X
		bcs .no_combi
		;stx .kunz
		jsr my_primm	: !tx ":", cr, 0
		lda #MODIFIED8	: .hinz = * - 1
		; use: call engine with both items
		jsr engine_use_A_with_X
		bcc +
			jsr my_primm
!if DEUTSCH {		!tx "Das geht nicht!", cr, 0
} else {		!tx "That does not work!", cr, 0	}
+		rts

!zone
select ; ask user to select one of the items in the current list (X must be first illegal index)
		stx .limit
		jsr get_key
		sec
!ct pet {	sbc #'a'	}	; petscii 'a'
		bcc .illegal_key
		cmp #MODIFIED8	: .limit = * - 1
		bcs .illegal_key
		tax	; remember index (list offset)
		clc
		adc #'a'	; ascii/iso/utf8 'a'
		jsr my_chrout
		; convert list offset to item offset
		lda itemlist_buf, x
		tax
		; return result
		clc	; ok
		rts
.illegal_key	sec	; fail
		rts

!zone
;internal_error	jsr my_primm
;		!tx "Internal error!", CR, 0
exit		ldx #MODIFIED8	: sp_buffer = * - 1
		txs
		rts

pre_situation ; called before a new situation (to init screen)
		; make some space
		jsr indent0
		jsr my_primm	: !tx color_std, petscii_CLEAR, petscii_REVSON, 0
!if SYSTEM = 64 {
		; invert first line for title
		ldx #39
		lda #160
--			sta SCREEN, x
			dex
			bpl --
}
!if SYSTEM = 128 {
		; invert first line for title
		lda #' '
		ldx #256 - LINE_LEN
-			jsr k_chrout	; yes, kernal, no need to filter through conv/wordwrap
			inx
			bne -
		lda #petscii_HOME	; yes, kernal, no need to filter through conv/wordwrap
		jsr k_chrout
}
		rts
