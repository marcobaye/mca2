;ACME 0.96.2
; Name		mca2
; Purpose	multiple choice adventure 2
; Author	(c) Marco Baye, 2017
; Licence	Free software
; Changes:
;  3 Sep 2016	First try, posted to forum64
;  4 Sep 2016	added some comments and shaved off a byte
; 24 Jun 2017	started work to convert from original mca to mca2
; 26 Jun 2017	got it to work

	!src <6502/std.a>	; for +bit16
	;!ct pet	; disabled, strings are now in UTF8

	DEUTSCH	= 1;0	; set to nonzero to make engine use german texts

; helper values
	MODIFIED8	= $ff

; zp variables
;!addr	fac1		= $61	; floating point registers could be used for temp storage
!addr	runptr		= $fb	; points to next bytecode instruction (also used for inline text output and scanning of usage list)
!addr	recursion_depth	= $fd	; counts recursion levels
!addr	tmp		= $fe

; system memory
!ifdef C128 {
!addr	is_PAL		= $0a03	; zero for NTSC, nonzero for PAL
	load_addr	= $1c01
} else {
!addr	is_PAL		= $02a6	; zero for NTSC, nonzero for PAL
	load_addr	= $0801
}
; basic header
	* = load_addr
		!wo line2, 2017
!ifdef C128 {
		!by $de, $20, $9c, $3a, $de, $20, $35, $3a, $fe, $02, $20, $30, $3a	; "GRAPHIC CLR:GRAPHIC 5:BANK 0:"
}
		!by $9e, $20	; "sys "
		!by '0' + entry % 10000 / 1000
		!by '0' + entry %  1000 /  100
		!by '0' + entry %   100 /   10
		!by '0' + entry %    10
		!pet $3a, $8f, " saufbox!", $0	; ":rem "
line2		!wo 0


xor_border ; this is used by the example program
		lda addr($d020)
		eor #15
		sta addr($d020)
		rts

wait_A_tenths ; wait for the number of .1 seconds given in A
		; convert .1s unit to frames:
		;	for PAL (50Hz), multiply by 5 (4+1)
		;	for NTSC (60Hz), multiply by 6 (4+1+1)
		sta .tenths
		asl	; *2
		asl	; *4
		clc
		adc #MODIFIED8	: .tenths = * - 1	; *5
		; for NTSC, add another time
		ldx is_PAL
		bne +
			clc
			adc .tenths	; *6
+		;FALLTHROUGH
wait_A_frames ; wait for the number of frames given in A
		tax
---
-			lda vic_controlv
			bpl -
		txa	; check for early exit (if called with A zero)
		beq +	; early exit
-			lda vic_controlv
			bmi -
		dex
		bne ---
+		rts

get_key ; wait for user to press key
---			jsr k_getin
			beq ---
		rts

; main program
entry ; entry point for SYS
		; init
		cld
		tsx
		stx sp_buffer
!ifdef C128 {
		lda #%....111.	; ram0, kernal, i/o
		sta addr($ff00)
		lda #<$c6b7	; this will skip the first few bytes of the original routine
		sta addr($033c)	; and therefore disable F key string expansion
}
		; FIXME - fadeout!
		lda #0
		sta vic_cborder
		sta vic_cbg
		jsr output_init
		; FIXME - fade in!
		jsr indent0
		jsr my_primm
		lda #30
		jsr wait_A_tenths
!if DEUTSCH {
		!tx color_WHITE, petscii_CLEAR, cr, cr
		;!tx"                                        "
		!tx "               Saufbox!", cr, cr,cr
		!tx cr, 0
		lda #10
		jsr wait_A_tenths
		jsr my_primm
		!tx "             präsentiert:", cr, cr, cr, cr, 0
		lda #10
		jsr wait_A_tenths
		jsr my_primm
		!tx "     Adventure of the Bunkerparty", cr, cr, cr, cr, 0
		lda #10
		jsr wait_A_tenths
		jsr my_primm
		!tx "    Code:      TheIncredibleBauchspeck", cr
		!tx "    Story:               Clumsy Wizard", cr, cr, cr
		!tx "Bitte eine Taste...", cr, 0
} else {
		!tx "Welcome to Multiple Choice Adventure 2!", cr, cr
		!tx "Press any key...", cr, 0
}
		jsr get_key
		jsr indent1
		jsr my_primm
!if DEUTSCH {
		!tx color_GREEN, petscii_CLEAR, cr, cr, "Der Magier Petrosilius hat sich letztens mit dem Gebiet der Nekromantie "
		!tx "befasst und hat seither ein kleines Problem. In seinem Keller haust nun ein "
		!tx "d", in_ä, "mlicher Ghoul, den er nicht mehr los wird. H", in_ä, "tte er das gewusst, w", in_ä, "re er "
		!tx "lieber bei seinen Fachgebieten Elementarismus und Illusionsmagie geblieben, "
		!tx "aber nun ist es zu sp", in_ä, "t.", cr
		!tx "Als ob das nicht schon genug ", in_Ä, "rger w", in_ä, "re, hat es sein Zaubererfreund Mabruk "
		!tx "auch noch gut mit ihm gemeint. Er versuchte den Ghoul mit einem "
		!tx "Beschw", in_ö, "rungsritual zu vernichten, doch leider laufen seither auch noch ein "
		!tx "Kalahuii und ein Palawaum in Petrosilius Turm herum...", cr
		!tx "Nun... Dann mal auf, mal schauen wie man die ungebetenen Gäste wieder "
		!tx "loswerden kann...", cr
		!tx cr
		!tx "(es ist sinnvoll, in der Bibliothek zu beginnen)", cr
} else {
		!error "Übersetzung fehlt"
}
		!tx 0
		jsr get_key
; now enter actual main loop:
---		jsr engine_new_location	; includes "restart" etc.
		; at start of game, show inventory once without being asked:
		lda once_per_game
		bne +
			inc once_per_game
			jsr inventory
+		; now wait for command
.get			jsr show_paths
			jsr get_key
			ldx #0
--				cmp keys_start, x
				beq .found
				inx
				cpx #keys_end - keys_start
				bne --
			jsr my_primm
!if DEUTSCH {	!tx "(falsche Taste, dr", in_ü, "ck '?' f", in_ü, "r Hilfe)", cr, 0
} else {	!tx "(wrong key, press '?' for help)", cr, 0 }
			jmp .get
.found ; call action handler
		lda action_lo, x
		sta .call
		lda action_hi, x
		sta .call + 1
		jsr MODIFIED16	: .call = * - 2
		jmp .get


help ; "?" command
		jsr my_primm
!if DEUTSCH {	!tx cr, "M", in_ö, "gliche Befehle:", cr, color_LGREEN
		!tx "  Nord S", in_ü, "d West Ost Hoch Runter", cr
		!tx "  Inventar(=F3) Grabsch Verliere", cr
		!tx "  Untersuche Benutze", cr, color_GREEN
		!tx "Immer nur den ersten Buchstaben tippen!", cr
		!tx "CLR/HOME(=F1) baut den Bildschirm neu auf.", cr
} else {	!tx "Allowed commands:", cr
		!tx "  North South West East Up Down", cr
		!error "Inventory(=F3) Take Lose", cr
		!error "Examine Use", cr
		!tx "Type the first character only!", cr
		!tx "CLR/HOME(=F1) will redisplay the screen.", cr
}
		!tx cr, 0
		rts

keys_start
!if DEUTSCH {	!pet petscii_CLEAR, petscii_HOME, petscii_F1, petscii_F3, "?nswohrigvub"
} else {	!pet petscii_CLEAR, petscii_HOME, petscii_F1, petscii_F3, "?nsweuditdEU"	}
keys_end

action_lo	!by <redisp, <redisp, <redisp, <inventory, <help, <go_n, <go_s, <go_w, <go_e, <go_u, <go_d, <inventory, <take, <drop, <examine, <use
action_hi	!by >redisp, >redisp, >redisp, >inventory, >help, >go_n, >go_s, >go_w, >go_e, >go_u, >go_d, >inventory, >take, >drop, >examine, >use

	redisp = engine_new_location

; direction commands
go_n		ldx #offset_NORTH
		+bit16
go_s		ldx #offset_SOUTH
		+bit16
go_w		ldx #offset_WEST
		+bit16
go_e		ldx #offset_EAST
		+bit16
go_u		ldx #offset_UP
		+bit16
go_d		ldx #offset_DOWN
		lda directions_hi, x
		beq .illegal
		tay
		lda directions_lo, x
		sty gamevars_hi + vo_PLAYER
		sta gamevars_lo + vo_PLAYER
		jmp engine_new_location
.illegal ; player chose an illegal direction
		jsr indent1
		jsr my_primm
!if DEUTSCH {	!tx "Richtung nicht m", in_ö, "glich, bitte eine andere w", in_ä, "hlen.", cr, 0
} else {	!tx "Illegal direction, please choose another.", cr, 0	}
		rts

inventory ; "inventory" command
		jsr my_primm
!if DEUTSCH {	!tx "Dinge im Inventar:", cr, 0
} else {	!tx "Things in inventory:", cr, 0	}
		ldy #>location_INVENTORY
		lda #<location_INVENTORY
		jsr itemlist_at_YYAA	; returns number in Y, A and Z ;)
		jmp itemlist_list

take ; "take" command
		jsr my_primm
!if DEUTSCH {	!tx "Grabsch:", cr, 0
} else {	!tx "Take:", cr, 0	}
		ldy gamevars_hi + vo_PLAYER
		lda gamevars_lo + vo_PLAYER
		jsr itemlist_at_YYAA	; returns number in Y, A and Z ;)
		bne +
			jsr my_primm
!if DEUTSCH {		!tx " Nichts da zum Grabschen!", cr, 0
} else {		!tx " There is nothing to take!", cr, 0	}
			rts
+		ldx #1	; yes, do size checking
		jsr itemlist_numbered	; returns limit (first illegal) character
		jsr select	; returns status in C and maybe index in X
		bcs .no_take
		; check size
		lda item_weight, x
		bmi .too_large
		; take: set item's location to INVENTORY
		lda #>location_INVENTORY
		sta gamevars_hi, x
		lda #<location_INVENTORY
		sta gamevars_lo, x
		jsr my_primm
!if DEUTSCH {	!tx " - ok, gegrabscht!", cr, 0
} else {	!tx " - ok, took it!", cr, 0	}
		rts

.too_large	jsr my_primm
!if DEUTSCH {	!tx " - nein, das kann man nicht mitnehmen!", cr, 0
} else {	!tx " - no, you cannot take that with you!", cr, 0	}
		rts

.no_take	jsr my_primm
!if DEUTSCH {	!tx " - nichts gegrabscht!", cr, 0
} else {	!tx " - nothing taken!", cr, 0	}
		rts

drop ; "drop" command
		jsr my_primm
!if DEUTSCH {	!tx "Verliere:", cr, 0
} else {	!tx "Drop:", cr, 0	}
		ldy #>location_INVENTORY
		lda #<location_INVENTORY
		jsr itemlist_at_YYAA	; returns number in Y, A and Z ;)
		bne +
			jsr my_primm
!if DEUTSCH {		!tx " Nichts da zum Verlieren!", cr, 0
} else {		!tx " There is nothing to drop!", cr, 0	}
			rts
+		ldx #0	; no size check
		jsr itemlist_numbered	; returns limit (first illegal) character
		jsr select	; returns status in C and maybe index in X
		bcs .no_drop
		; drop: copy player's location to item's location
		lda gamevars_hi + vo_PLAYER
		sta gamevars_hi, x
		lda gamevars_lo + vo_PLAYER
		sta gamevars_lo, x
		jsr my_primm
!if DEUTSCH {	!tx " - ok, verloren!", cr, 0
} else {	!tx " - ok, dropped it!", cr, 0	}
		rts

.no_drop	jsr my_primm
!if DEUTSCH {	!tx " - nichts verloren!", cr, 0
} else {	!tx " - nothing dropped!", cr, 0	}
		rts

examine ; "examine" command
		jsr my_primm
!if DEUTSCH {	!tx "Untersuche:", cr, 0
} else {	!tx "Examine:", cr, 0	}
		; get list of items at location
		ldy gamevars_hi + vo_PLAYER
		lda gamevars_lo + vo_PLAYER
		jsr itemlist_at_YYAA	; returns number in Y, A and Z ;)
		; extend list with items in inventory
		tax
		ldy #>location_INVENTORY
		lda #<location_INVENTORY
		jsr itemlist_plus_at_YYAA	; returns number in Y, A and Z ;)
		bne +
			jsr my_primm
!if DEUTSCH {		!tx " Nichts da zum Untersuchen!", cr, 0
} else {		!tx " There is nothing to examine!", cr, 0	}
			rts
+		ldx #0	; no size check
		jsr itemlist_numbered	; returns limit (first illegal) character
		jsr select	; returns status in C and maybe index in X
		bcs .no_examine
		; examine: execute item's description code
		jsr my_primm	: !tx ":", cr, " ", color_LGREEN, 0
		jsr indent1
		jsr engine_describe_X
		jsr my_primm	: !tx color_GREEN, cr, 0
		rts

.no_examine	jsr my_primm
!if DEUTSCH {	!tx " - nichts untersucht!", cr, 0
} else {	!tx " - nothing examined!", cr, 0	}
		rts

use ; "use" command
		jsr my_primm
!if DEUTSCH {	!tx "Benutze:", cr, 0
} else {	!tx "Use:", cr, 0	}
		; get list of items in inventory
		ldy #>location_INVENTORY
		lda #<location_INVENTORY
		jsr itemlist_at_YYAA	; returns number in Y, A and Z ;)
		; extend list with items at location
		tax
		ldy gamevars_hi + vo_PLAYER
		lda gamevars_lo + vo_PLAYER
		jsr itemlist_plus_at_YYAA	; returns number in Y, A and Z ;)
		bne +
			jsr my_primm
!if DEUTSCH {		!tx " Nichts da zum Benutzen!", cr, 0
} else {		!tx " There is nothing to use!", cr, 0	}
			rts
+		sta .length	; remember number of items
		; choose first item
		ldx #0	; no size check
		jsr itemlist_numbered	; returns limit (first illegal) character
		jsr select	; returns status in C and maybe index in X
		bcs .no_use
		stx .hinz
		; choose second item
		jsr my_primm
!if DEUTSCH {	!tx " mit:", cr, 0
} else {	!tx " with:", cr, 0	}
		lda #MODIFIED8	: .length = * - 1
		ldx #0	; no size check
		jsr itemlist_numbered	; returns limit (first illegal) character
		jsr select	; returns status in C and maybe index in X
		bcs .no_use
		;stx .kunz
		lda #MODIFIED8	: .hinz = * - 1
		; use: call engine with both items
		jsr engine_use_A_with_X
		bcc +
			jsr my_primm
!if DEUTSCH {		!tx " - das geht nicht!", cr, 0
} else {		!tx " - that does not work!", cr, 0	}
+		rts

.no_use		jsr my_primm
!if DEUTSCH {	!tx " - nichts benutzt!", cr, 0
} else {	!tx " - nothing used!", cr, 0	}
		rts


!zone
select ; ask user to select one of the items in the current list (A must be first illegal char)
		sta .limit
		jsr get_key
		cmp #'1'
		bcc .illegal_key
		cmp #MODIFIED8	: .limit = * - 1
		bcs .illegal_key
		;pha
		jsr k_chrout	; yes, KERNAL out - because input characters are petscii
		;pla
		; convert digit to list offset
		sec
		sbc #'1'
		; convert list offset to item offset
		tax
		lda itemlist, x
		tax
		; return result
		clc	; ok
		rts
.illegal_key	sec	; fail
		rts

!zone
;internal_error	jsr my_primm
;		!tx "Internal error!", CR, 0
exit		ldx #MODIFIED8	: sp_buffer = * - 1
		txs
		rts

pre_situation ; called before a new situation (to clear screen?)
		; make some space
		jsr indent0
		jsr my_primm	: !tx petscii_CLEAR, petscii_REVSON, 0
!ifdef C128 {
		; invert first line for title
		lda #' '
		ldx #256 - LINE_LEN
-			jsr k_chrout	; yes, kernal, no need to filter through conv/wordwrap
			inx
			bne -
		lda #petscii_HOME	; yes, kernal, no need to filter through conv/wordwrap
		jsr k_chrout
} else {
		; invert first line for title
		ldx #39
		lda #160
--			sta SCREEN, x
			dex
			bpl --
}
		rts
