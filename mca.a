;ACME 0.96.2
; Name		mca2
; Purpose	multiple choice adventure 2
; Author	(c) Marco Baye, 2017
; Licence	Free software
; Changes:
;  3 Sep 2016	First try, posted to forum64
;  4 Sep 2016	added some comments and shaved off a byte
; 24 Jun 2017	started work to convert from original mca to mca2

	!src <cbm/c64/petscii.a>
	!src <cbm/c64/vic.a>
	!src <cbm/c64/kernal.a>
	!ct pet

; helper values
	CR		= 13
	MODIFIED8	= $ff

; zp variables
!addr	sitptr		= $fd	; current situation
!addr	txtptr		= $fb	; text pointer

; basic header
	* = $0801
		!wo line2, 2017
		!by $9e, $20	; "sys "
		!by '0' + entry % 10000 / 1000
		!by '0' + entry %  1000 /  100
		!by '0' + entry %   100 /   10
		!by '0' + entry %    10
		!pet $3a, $8f, " saufbox!", $0	; ":rem "
line2		!wo 0

; main program
entry ; entry point for SYS
		; init
		cld
		lda #0
		sta addr($d020)
		sta addr($d021)
		lda #<welcome_text
		ldx #>welcome_text
		jsr print_xxaa_text

		jsr init_vars
		jmp engine

welcome_text	!tx petscii_LOCK, petscii_LOWERCASE, petscii_GREEN, petscii_CLEAR
		!tx "Welcome to Multiple Choice Adventure 2!", CR, CR, 0

init_vars
		; let situation ptr point to start situation
; FIXME - this should be done via some kind of "init-all-vars" loop!
		lda #<s_start
		ldx #>s_start
		sta sitptr
		stx sitptr + 1
		rts

engine
mainloop	;
		jsr print_sit_text	; => Y is 0
		lda #CR
		jsr k_chrout
		ldx #0	; no choices yet
		; now iterate over choices
		beq iter_choices
		;--
next_choice		; copy target
			sta target_high, x
			iny
			lda (sitptr), y
			sta target_low, x
			lda #' '
			jsr k_chrout
			; output choice character
			txa
			clc
			adc #FIRST_CHOICE_CHARACTER
			jsr k_chrout
			lda #' '
			jsr k_chrout
			; advance pointer
			sec	; +1
			tya
			adc sitptr
			sta sitptr
			bcc +
				inc sitptr + 1
+			; output choice text
			jsr print_sit_text
			lda #CR
			jsr k_chrout
			inx	; count this choice
iter_choices		iny
			lda (sitptr), y
			bne next_choice
		; no more choices
		stx number_of_choices
		; ask user for input
		lda #'?'
		jsr k_chrout
		; wait for valid input
---			jsr k_getin
			tay	; remember original character
			; convert to offset and check limits while at it
			sec
			sbc #FIRST_CHOICE_CHARACTER
			bcc ---	; input too low
			cmp #MODIFIED8:number_of_choices = * - 1
			bcs ---	; input too high
		; update situation pointer
		tax
		lda target_low, x
		sta sitptr
		lda target_high, x
		sta sitptr + 1
		; output entered character
		tya
		jsr k_chrout
		; add two newlines
		lda #CR
		jsr k_chrout
		lda #CR
		jsr k_chrout
		; start over
		jmp mainloop

; entry: -
; exit: txtptr points to terminating zero, A=0, X preserved, Y=0
print_sit_text	lda sitptr
		ldx sitptr + 1
; entry: XXAA points to text
; exit: txtptr points to terminating zero, A=0, X preserved, Y=0
print_xxaa_text	sta txtptr
		stx txtptr + 1
; entry: txtptr points to text
; exit: txtptr points to terminating zero, A=0, X preserved, Y=0
print_ptr_text	ldy txtptr	; get low byte of ptr - 1
		lda #0	; and zero ptr low, so "(txtptr), y" points to text
		sta txtptr
		beq +++
		;--
---			jsr k_chrout
			iny
			bne +++
				inc txtptr + 1	; fix high byte
+++			lda (txtptr), y
			bne ---
		; write updated address
		sty txtptr
		tay
		rts

	; first command should be 0 of course, but I want to be able to tell it apart from text terminator...
	CMD_PRINT	= 1
	CMD_END_OF_SIT	= 2	; end of situation
	CMD_NORTH	= 3
	CMD_SOUTH	= 4
	CMD_EAST	= 5
	CMD_WEST	= 6
	CMD_UP		= 7
	CMD_DOWN	= 8
	;CMD_GOTO	= 9	; to implement if/else/endif blocks
!macro print		{!by CMD_PRINT		}
!macro terminate	{!by 0			}
!macro end_sit		{!by CMD_END_OF_SIT	}
!macro north	.target	{!by CMD_NORTH:	!wo .target	}
!macro south	.target {!by CMD_SOUTH:	!wo .target	}
!macro east	.target {!by CMD_EAST:	!wo .target	}
!macro west	.target {!by CMD_WEST:	!wo .target	}
!macro up	.target {!by CMD_UP:	!wo .target	}
!macro down	.target {!by CMD_DOWN:	!wo .target	}
;!macro goto	.target	{!by CMD_GOTO:	!wo .target	}
	cr		= 13


	MAX_CHOICES		= 9	; 1..9
	FIRST_CHOICE_CHARACTER	= '1'
	SEPARATOR		= 0	; after text, after each choice, after situation
; example situation:
;name	!tx "description", CR
;	!tx "description", CR
;	!tx "description"
;	!by 0 (end of text, start of choices)
;	;choices:
;	!be16 target (where choice leads)
;	!tx "text of choice", 0
;	!be16 target (where choice leads)
;	!tx "text of choice", 0
;	[...]
;	!by 0 (end of situation)

	; macro to begin new situation
	!macro sit ~.name {
		!if CHOICES = 0 {
			!error "Previous situation had no choices!"
		}
		!set CHOICES = 0
		!by SEPARATOR, SEPARATOR	; close choice and situation
.name
	}

	; macro to add a choice to a situation
	!macro choice .target {
		!if CHOICES = MAX_CHOICES {
			!error "Too many choices"
		}
		!set CHOICES = CHOICES + 1
		!by SEPARATOR	; end previous choice (or description if first choice)
		!by >.target, <.target	; hi/lo order allows zero to terminate
	}

	!set CHOICES = 1	; non-null so macro does not complain on first situation
	!src "_autogenerated.a"
	+sit ~dummy_situation	; make sure last situation is closed

; external storage:
target_low
target_high	= target_low + MAX_CHOICES
