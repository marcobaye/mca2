;ACME 0.96.2

	!src <cbm/petscii.a>
	petscii_LOWERCASE	=  14	; switch to lowercase/uppercase character set
	petscii_F1	= 133:	petscii_F2	= 137
	petscii_F3	= 134:	petscii_F4	= 138
	petscii_F5	= 135:	petscii_F6	= 139
	petscii_F7	= 136:	petscii_F8	= 140
	!src <cbm/kernal.a>
!if SYSTEM = 64 {
	!src <cbm/c64/vic.a>
}
!if SYSTEM = 128 {
	!src <cbm/c128/vic.a>	; only needed for timing via frame counting
	!src <cbm/c128/vdc.a>
}

; helper values
	CR		= 13
	cr		= 13
!if ISO {
	; ISO8859-1
	colorbase	= $b0	; b0..bf
	Ä		= $c4
	Ö		= $d6
	Ü		= $dc
	ß		= $df
	ä		= $e4
	ö		= $f6
	ü		= $fc
} else {
	; UTF8 (0xc2 prefix will be just ignored)
	Ä		= $84
	Ö		= $96
	Ü		= $9c
	ß		= $9f
	ä		= $a4
	ö		= $b6
	ü		= $bc
	colorbase	= $f0	; f0..ff
}
!if SYSTEM = 264 {
ted_colors ; look-up table to convert vic colors to matching ted color/luma combo
		!by $00, $71, $22, $63, $44, $45, $26, $67
		!by $48, $19, $42, $11, $31, $65, $56, $51
}
	; new color codes (because some PetSCII codes clash with the UTF8 conversion)
!if (SYSTEM = 64) OR (SYSTEM = 264) {
	; vic-ii colors:
	color_BLACK	= colorbase + $0
	color_WHITE	= colorbase + $1
	color_RED	= colorbase + $2
	color_CYAN	= colorbase + $3
	color_PURPLE	= colorbase + $4
	color_GREEN	= colorbase + $5
	color_BLUE	= colorbase + $6
	color_YELLOW	= colorbase + $7
	color_ORANGE	= colorbase + $8
	color_BROWN	= colorbase + $9
	color_LRED	= colorbase + $a
	color_GRAY1	= colorbase + $b
	color_GRAY2	= colorbase + $c
	color_LGREEN	= colorbase + $d
	color_LBLUE	= colorbase + $e
	color_GRAY3	= colorbase + $f
	; ted colors must be substituted using a lookup table!
}
!if SYSTEM = 128 {
	; vdc colors and a mapping to vic color names:
	color_DBLACK	= colorbase + $0	: color_BLACK	= color_DBLACK
	color_LBLACK	= colorbase + $1	: color_GRAY1	= color_LBLACK
	color_DBLUE	= colorbase + $2	: color_BLUE	= color_DBLUE
	color_LBLUE	= colorbase + $3
	color_DGREEN	= colorbase + $4	: color_GREEN	= color_DGREEN
	color_LGREEN	= colorbase + $5
	color_DCYAN	= colorbase + $6	: color_GRAY2	= color_DCYAN
	color_LCYAN	= colorbase + $7	: color_CYAN	= color_LCYAN
	color_DRED	= colorbase + $8	: color_RED	= color_DRED
	color_LRED	= colorbase + $9
	color_DPURPLE	= colorbase + $a	: color_PURPLE	= color_LPURPLE
	color_LPURPLE	= colorbase + $b	: color_ORANGE	= color_DPURPLE
	color_DYELLOW	= colorbase + $c	: color_BROWN	= color_DYELLOW
	color_LYELLOW	= colorbase + $d	: color_YELLOW	= color_LYELLOW
	color_DWHITE	= colorbase + $e	: color_GRAY3	= color_DWHITE
	color_LWHITE	= colorbase + $f	: color_WHITE	= color_LWHITE
	; basic7 maps GRAY1 and GRAY2 the other way around, but I like this better.
}
; system memory
!if SYSTEM = 64 {
!addr	currentcolor	= $0286
!addr	cbmshift	= $0291
	LINE_LEN	= 40
!addr	z_quote_mode	= $d4
!addr	screenpage	= $0288
}
!if SYSTEM = 128 {
!addr	currentcolor	= $f1
!addr	cbmshift	= $f7
	LINE_LEN	= 80
!addr	z_quote_mode	= $f4
!addr	vdcw		= $cdcc
}
!if SYSTEM = 264 {
!addr	currentcolor	= $053b
!addr	cbmshift	= $0547
	LINE_LEN	= 40
!addr	z_quote_mode	= $cb
!addr	SCREEN		= $0c00
}

!if SYSTEM = 128 {
	.charcount = tmp
copycharset ; copy data to vdc ram with gaps, XORing with A
		sta .xor
		lda #<charset
		sta .ptr
		lda #>charset
		sta .ptr + 1
		lda #128
		sta .charcount
-----			; eight real bytes
			ldy #8
---				lda MODIFIED16	: .ptr = * - 2
				eor #MODIFIED8	: .xor = * - 1
				inc .ptr
				bne +
					inc .ptr + 1
+				ldx #vdcr_access
				jsr vdcw
				dey
				bne ---
			; eight fake bytes
			ldy #8
---				lda #0
				ldx #vdcr_access
				jsr vdcw
				dey
				bne ---
			; all chars done?
			inc .charcount
			bne -----
		rts
}

output_init ; setup own charset, vic registers, etc.
!if SYSTEM = 64 {
		; ECB + bitmap + disable => all black
		lda #%.##.#.##
		sta vic_controlv
		; forbid cbm/shift
		lda #$80
		sta cbmshift
		; highest vic bank
		lda #%#..#.#..
		sta addr($dd00)
		; screen at $cc00, charset at $d000
!addr	SCREEN = $cc00
		lda #((SCREEN & $3c00) >> 6) | %0100
		sta vic_ram
		; copy charset
		lda #$31	; ram and charset
		ldx #0
		sei
			sta addr(1)
---				!for i, 0, 3 {
					lda charset + i * 256, x
					sta addr($d000 + i * 256), x
					eor #$ff
					sta addr($d400 + i * 256), x
				}
				inx
				bne ---
			lda #$36	; ram, i/o, kernal
			sta addr(1)
		cli
		; tell kernal where screen is
		lda #>SCREEN
		sta screenpage
		; now CLEAR to init screen
		jsr my_primm
		!tx color_std, petscii_CLEAR, 0
		; re-enable vic display
		lda #%...##.##
		sta vic_controlv
}
!if SYSTEM = 128 {
		; forbid cbm/shift
		lda #$80
		sta cbmshift
		; FIXME - pimp vdc to 9x10 matrix?
		; copy charset:
		; start address in vdc ram should be $3000 (lowercase charset)
		ldx #vdcr_ram_hi
		lda #>$3000
		jsr vdcw
		ldx #vdcr_ram_lo
		lda #<$3000
		jsr vdcw
		; copy first half
		lda #0
		jsr copycharset
		; copy reverse half
		lda #255
		jsr copycharset
		; now CLEAR to init screen
		jsr my_primm
		!tx petscii_LOWERCASE, color_std, petscii_CLEAR, 0
}
!if SYSTEM = 264 {
		; init ted and charset:
		; forbid cbm/shift
		lda #$80
		sta cbmshift
		; charset in ram
		lda #$c3
		sta addr($ff12)
		; copy charset
		ldx #0
---			!for i, 0, 3 {
				lda charset + i * 256, x
				sta addr($d400 + i * 256), x
			}
			inx
			bne ---
		; now CLEAR to init screen
		jsr my_primm
		!tx petscii_LOWERCASE, color_std, petscii_CLEAR, 0
}
		rts

output_set_colors ; this will be called after credits screen
!if SYSTEM = 64 {
		lda #color_border
		sta vic_cborder
		lda #color_background
		sta vic_cbg
}
!if SYSTEM = 128 {
		ldx #vdcr_color
		lda #((color_std & $f) << 4) | (color_background & $f)
		jsr vdcw
}
!if SYSTEM = 264 {
		lda ted_colors + (color_border & $f)
		sta addr($ff19)	; border
		lda ted_colors + (color_background & $f)
		sta addr($ff15)	; background
}
		rts

; wrapper for CHROUT (to convert UTF8 to PetSCII)
my_chrout ; must keep X/Y!
		; check for A..Z
		cmp #'A'
		bcc +++	; $00..$40 are kept
		cmp #'Z' + 1
		bcs +
			; convert A..Z
			ora #$80
			jmp wordwrapped
+		; check for a..z
		cmp #'a'
		bcc +++	; [\]^_` are kept
		cmp #'z' + 1
		bcs +
			; convert a..z
			and #$df
			jmp wordwrapped
+		; check for äöüßÄÖÜ and replace
!if ISO {
		cmp #ä
		beq .ä
		cmp #ö
		beq .ö
		cmp #ü
		beq .ü
}
;encoded as 0xc3 0x80 .. 0xc3 0x9f:
;	ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß	ÄÖÜß are $84, $96, $9c, $9f
;encoded as 0xc3 0xa0 .. 0xc3 0xbf:
;	àáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ	äöü are $a4, $b6, $bc
		; three of these clash with original petscii color codes, therefore this game now uses its own set of color codes (see above)
		cmp #Ä	; petscii_HELP (so forget it)
		beq .Ä
		cmp #Ö	; petscii_LRED
		beq .Ö
		cmp #Ü	; petscii_PURPLE
		beq .Ü
		cmp #ß	; petscii_CYAN
		beq .ß
; äöü codes are kept, because they are mapped to graphics characters anyway (put glyphs at correct position in charset!)
		cmp #$c3	; prefix code? drop! (horizontal bar)
		beq .rts
		; check for own color codes ($bX or $fX)
		cmp #colorbase
		bcc +++
			; set color
			pha
			lda #0	; output dummy code to flush buffer
			jsr wordwrapped
			pla
!if SYSTEM = 128 {
			and #$f	; keep color
			ora #%#.......	; 2nd charset, no revs, no underline, no flash
}
!if SYSTEM = 264 {
			; lookup in ted_colors but keep X and Y!
			stx .tmpx
			and #$f	; keep color
			tax
			lda ted_colors, x
			ldx #MODIFIED8	: .tmpx = * - 1
}
			sta currentcolor	; new characters have correct color
.rts			rts
		; replace ÄÖÜß with correct codes for chosen charset
!if ISO {
.ä		lda #$a4
		+bit16
.ö		lda #$b6
		+bit16
.ü		lda #$bc
		+bit16
}
.Ä		lda #$ac
		+bit16
.Ö		lda #$b5
		+bit16
.Ü		lda #$bb
		+bit16
.ß		lda #$be
+++		jmp wordwrapped

; print immediate
my_primm	pla	; get low byte of return address - 1
		tay	; into Y
		pla	; get high byte of return address - 1
		sta .primm_ptr + 1	; to ptr high
		jmp +
---			jsr my_chrout
+			iny
			bne +
				inc .primm_ptr + 1	; fix high byte
+			; high byte gets MODIFIED, but low byte stays zero!
			lda addr($ff00), y	: .primm_ptr = * - 2
			bne ---
		; push updated address onto stack
		lda .primm_ptr + 1
		pha
		tya
		pha
		rts	; return to caller (after zero-terminated text)


print_AAYY ; print zero-terminated string. keeps X.
		sta .print_ptr + 1
		; high byte gets MODIFIED, but low byte stays zero!
		jmp +
---			jsr my_chrout
			iny
			bne +
				inc .print_ptr + 1	; fix high byte
+			lda addr($ff00), y	: .print_ptr = * - 2
			bne ---
		rts

; word wrap:
.xbuf		!by 0
.space_left	!by LINE_LEN
.chars_in_buf	!by 0
.indents	!by 0
indent0		lda #0
		+bit16
indent1		lda #1
		sta .indents
		rts
wordwrapped ; output character with automatic word wrap. KEEPS X/Y!
		cmp #$21	; low control codes and space flush buffer
		bcc .control_or_space
		cmp #$80	; printables with msb clear?
		bcc .printable
		cmp #$a0	; high control codes flush buffer (shift space could be used as nbsp)
		bcc .control_hi
		; printables with msb set
.printable ; append to buffer
		stx .xbuf
		ldx .chars_in_buf
		sta linebuf, x
		cpx #LINE_LEN	; buffer overrun? (old value!)
		bne .end_append
			; buffer overran, so fuck the word wrap, just output it
			; "chars_left" does not change in this case!
			jsr linebuf_flush
			; and move the new character to start of buf
			lda linebuf + LINE_LEN
			sta linebuf
.end_append	inc .chars_in_buf
		ldx .xbuf
		rts

.control_or_space
		cmp #' '
		beq .space
		cmp #cr
		beq .cr
		cmp #petscii_HOME
		beq .home
.control_hi ; A is separator code, so flush contents of buffer, then output A
		cmp #petscii_CLEAR
		beq .clear
.control	pha
		stx .xbuf

		; does buffer fit in current line?
		lda .space_left
		cmp .chars_in_buf
		bcs +
			; too little space on line, so do wrap
			; first force carriage return
			lda #cr
			jsr k_chrout
			jsr .new_line

			lda .space_left
			cmp .chars_in_buf
+		bne .small
			; fits exactly
			jsr linebuf_flush
			jsr .new_line

			ldx .xbuf
			pla
			jsr k_chrout
			sec	; next space could be skipped
			rts

.small		lda .space_left
		sec
		sbc .chars_in_buf
		sta .space_left
		jsr linebuf_flush

		ldx .xbuf
		pla
		jsr k_chrout
		clc	; ok
		rts

.new_line	lda #LINE_LEN	; next line is completely unused
		sta .space_left
		ldx .indents
		beq +
			lda #' '
			jsr k_chrout
			dec .space_left
+		rts

.space ; code is space
		lda #0	; output dummy code instead
		jsr .control
		bcs +
			; space must be output
			lda #' '
			jsr k_chrout
			dec .space_left
			bne +
				jsr .new_line
+		rts

.home
.clear
.cr		jsr .control
		lda #LINE_LEN
		sta .space_left
		rts

linebuf_flush ; output what's in the line buffer
		ldx #0
		beq +
		;--
---			lda linebuf, x
			jsr k_chrout
			lda #0
			sta z_quote_mode
			inx
+			cpx .chars_in_buf
			bne ---
		ldx #0
		stx .chars_in_buf
		rts
